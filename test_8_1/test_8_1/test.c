#include <stdio.h>

//深度剖析数据在内存中的存储

//1. 数据类型介绍
//前面我们已经学习了基本的内置类型以及他们所占存储空间的大小：
//char        1     //字符数据类型
//short       2     //短整型
//int         4     //整形
//long        4/8   //长整型
//long long   8     //更长的整形
//float       4     //单精度浮点数
//double      8     //双精度浮点数

//类型的意义：
//1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
//2. 如何看待内存空间的视角。

//1.1 类型的基本归类：
//整形家族：
//整型表示的范围：limits.h中定义

//char ->字符的本质是ASCII码值，是整型，所以划分到整型家族
//char到底是signed char还是unsigned char，标准是未定义的，取决于编译器的实现。
//char
		//unsigned char
		//signed char
//short
		//unsigned short[int]
		//signed short[int]
//int
		//unsigned int
		//signed int
//long
		//unsigned long[int]
		//signed long[int]
//long long
		//unsigned long long[int]
		//signed long long[int]

//浮点数家族：
//只要是表示小数就可以使用浮点型
//flaot的精度低，存储的数值范围较小；double的精度高，存储的数据范围更大
//float
//double

//构造类型：自定义类型 - 我们可以自己创建出新的类型
//> 数组类型		比如：int arr[2]  数组arr的类型就是int [2]
//> 结构体类型	struct
//> 枚举类型		enum
//> 联合类型		union

//指针类型：
//int* pi;
//char* pc;
//float* pf;
//void* pv;

//空类型：
//void 表示空类型（无类型）
//通常应用于函数的返回类型、函数的参数、指针类型。

//第一个void 表示函数不会返回值
//第二个void 表示函数不需要任何参数
//void test(void)
//{
//
//}
//
//int main()
//{
//	test();
//
//	return 0;
//}

//2. 整形在内存中的存储
//我们之前讲过一个变量的创建是要在内存中开辟空间的。空间的大小是根据不同的类型而决定的。
//那接下来我们谈谈数据在所开辟内存中到底是如何存储的？

//数值有不同的表示形式
//2进制
//8进制
//10进制
//16进制

//十进制的21
//0b10101
//025
//21
//0x15

//2.1 原码、反码、补码
//整数的2进制也有三种表示形式：
//1. 正的整数，原码、反码、补码相同
//2. 负的整数，原码、反码、补码是需要计算的
//原码：直接通过正负的形式写出的二进制序列就是原码
//反码：原码的符号位不变，其他位按位取反得到的就是反码
//补码：反码+1就是补码
//整数内存中存放的是补码的二进制序列

//int main()
//{
//	int a = 20;
//	//20
//	//00000000000000000000000000010100
//	//0x00 00 00 14
//	//00000000000000000000000000010100
//	//00000000000000000000000000010100
//	//
//	int b = -10;
//	//-10
//	//10000000000000000000000000001010
//	//0x80 00 00 0a
//	//11111111111111111111111111110101
//	//0xff ff ff f5
//	//11111111111111111111111111110110
//	//0xff ff ff f6
//	//
//
//	return 0;
//}

//2.2 大小端介绍
//什么大端小端：
//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。

//0x11 22 33 44
//11 22 33 44 (大端字节序存储)                                        44 33 22 11(大端字节序存储)
//低地址                                                                                 高地址
//大端【字节序】存储：把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大端字节序存储。
//小端【字节序】存储：把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储。

//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//
//	return 0;
//}

//2.3 练习
//下面程序输出什么？
//题一：
//有符号的char - -128~127
//无符号的char - 0~255
//有符号的short - -32768~32767
//无符号的short - 0~65535
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111
//	//截断
//	//11111111 - a
//	//%d是打印有符号的整型
//	//整型提升
//	//11111111111111111111111111111111 - 内存中的补码
//	//10000000000000000000000000000000
//	//10000000000000000000000000000001 -> -1
//
//	unsigned char c = -1;
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111 - 补码
//	//截断
//	//11111111 - c
//	//整型提升
//	//00000000000000000000000011111111 - 内存中的补码
//	//00000000000000000000000011111111
//	//00000000000000000000000011111111 -> 255
//
//	printf("a=%d, b=%d, c=%d", a, b, c);
//	//-1 -1 255
//
//	return 0;
//}

//题二：
//int main()
//{
//	//char  -128~127
//	char a = -128;
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111
//	//11111111111111111111111110000000
//	//截断
//	//10000000 - a
//	//整型提升
//	//11111111111111111111111110000000 - 内存中的补码
//	//11111111111111111111111110000000
//	//11111111111111111111111110000000 -> 4294967168
//	printf("%u\n", a);//%u - 打印无符号整数
//	//4294967168
//
//	//11111111111111111111111110000000
//	//10000000000000000000000001111111
//	//10000000000000000000000010000000 -> -128
//	printf("%d\n", a);//%d - 打印有符号整数
//	//-128
//
//	return 0;
//}

//题三：
//int main()
//{
//	//char  -128~127
//	char a = 128;
//	//00000000000000000000000010000000
//	//00000000000000000000000010000000
//	//00000000000000000000000010000000
//	//截断
//	//10000000
//	//整型提升
//	//11111111111111111111111110000000
//	//11111111111111111111111110000000
//	//11111111111111111111111110000000 -> 4294967168
//	printf("%u\n", a);
//	//4294967168
//
//	//11111111111111111111111110000000
//	//10000000000000000000000001111111
//	//10000000000000000000000010000000 -> -128
//	printf("%d\n", a);
//	//-128
//
//	return 0;
//}

//题四：
//按照补码的形式进行运算，最后格式化成为有符号整数
//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100 - -20的补码
//	//
//	unsigned int j = 10;
//	//00000000000000000000000000001010
//	//00000000000000000000000000001010
//	//00000000000000000000000000001010 - 10的补码
//
//	printf("%d\n", i + j);
//	//11111111111111111111111111101100
//	//00000000000000000000000000001010
//	//11111111111111111111111111110110 - i+j的补码
//	//10000000000000000000000000001001
//	//10000000000000000000000000001010 -> -10
//
//	return 0;
//}

//题五：死循环
#include <windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(1000);//休眠1000毫秒
//	}
//	//0-1 -> i=-1时，放入unsigned int i中，所以：
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111
//	//
//	//11111111111111111111111111111111 - 补码
//	//11111111111111111111111111111111
//	//11111111111111111111111111111111 -> 4294967295 其实输出的是这个数
//	// 
//	//然后 -1-1 -> -2     
//	//......
//
//	return 0;
//}

//题六：
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//arr[i] --> char	-128~127
//	//-1 -2 -3 -4 ... -1000    err
//	//-1 -2 ... -128 127 126 ... 3 2 1 0 -1 ...
//	//128+127 = 255
//	printf("%d", strlen(a));//255
//	//strlen 是求字符串的长度，关注的是字符串中'\0'（数字0）之前出现多少字符
//
//	return 0;
//}

//题七：死循环
//unsigned char i = 0;
////unsigned char 类型的取值范围是0~255
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//
//	return 0;
//}

//题八：输出什么  >
//#include <string.h>
//int main()
//{
//	//size_t -> unsigned int
//	//无符号数-无符号数=无符号数
//	if (strlen("abc") - strlen("abcdef") >= 0)//3-6 = -3，-3被当作无符号整数看待时，将是一个非常大的正数
//	//可以改成：
//	//if ((int)strlen("abc") - (int)strlen("abcdef") >= 0)
//	//if (strlen("abc") > strlen("abcdef"))
//		printf(">\n");
//	else
//		printf("<\n");
//
//	return 0;
//}

//3. 浮点型在内存中的存储
//常见的浮点数：
//3.14159
//1E10
//浮点数家族包括：float、double、long double 类型。
//浮点数表示的范围：float.h中定义

//3.1 一个例子
//浮点数存储的例子：

//浮点数的存储和获取的方式与整型的存储和获取的方式是有所差异的
//以浮点数的形式放进去就应该以浮点数的形式把它拿出来
//以整型的形式放进去就应该以整型的形式把它拿出来
int main()
{
	int n = 9;
	//00000000000000000000000000001001
	//0 00000000 00000000000000000001001
	//E=-126
	//M=0.00000000000000000001001
	//+ 0.00000000000000000001001 * 2^-126   以*pFloat的视角来看
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);//9
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
	*pFloat = 9.0;
	//1001.0
	//1.001 * 2^3
	//S=0 E=3 M=1.001
	//0 10000010 00100000000000000000000
	//01000001000100000000000000000000   以n的视角来看
	printf("num的值为：%d\n", n);//1091567616
	printf("*pFloat的值为：%f\n", *pFloat);//9.0

	return 0;
}

//3.2 浮点数存储规则
//num 和 * pFloat 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？
//根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1) ^ S * M * 2 ^ E
//(-1) ^ S表示符号位，当S = 0，V为正数；当S = 1，V为负数。
//M表示有效数字，大于等于1，小于2。
//2 ^ E表示指数位。

//举例来说：
//十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2 ^ 2 。
//那么，按照上面V的格式，可以得出S = 0，M = 1.01，E = 2。
//十进制的 - 5.0，写成二进制是 - 101.0 ，相当于 - 1.01×2 ^ 2 。那么，S = 1，M = 1.01，E = 2。

//IEEE 754规定：
//对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。
//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

//IEEE 754对有效数字M和指数E，还有一些特别规定。
//前面说过， 1 ≤ M < 2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。
//
//IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，
//只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，
//将第一位的1舍去以后，等于可以保存24位有效数字。
//
//至于指数E，情况就比较复杂。
//首先，E为一个无符号整数（unsigned int）
//这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，
//所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
//比如，2 ^ 10的E是10，所以保存成32位浮点数时，必须保存成10 + 127 = 137，即10001001。
// 
//float -> E(真实值) + 127(中间值) -> 126-存储
//double -> E(真实值) + 1023(中间值) -> 1022-存储

//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//1.011*2^2
//	//s=0 m=1.011 e=2
//	//2+127 = 129
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//0x40 b0 00 00
//
//	return 0;
//}

//然后，指数E从内存中取出还可以再分成三种情况：
//E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
//
//比如：
//0.5（1 / 2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0 * 2 ^ (-1)，其阶码为 - 1 + 127 = 126，
//表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:
//0 01111110 00000000000000000000000
//
//E全为0
//这时，浮点数的指数E等于1 - 127（或者1 - 1023）即为真实值，
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
//
//E全为1
//这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）。















